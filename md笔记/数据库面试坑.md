# 数据库面试坑

**聚集索引**。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。

**一个表只能有一个**

是一种稀疏索引，数据页上一级的索引页存储的是**页指针（指示索引页地址）**，而不是行指针



**非聚集索引**。则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录



 1、向表中插入新数据行
    如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加到表的末尾位置。而建立了聚簇索引的数据表则不同：最简单的情况下，插入操作根据索引找到对应的数据页，然后通过挪动已有的记录为新数据腾出空间，最后插入数据。如果数据页已满，则需要拆分数据页，调整索引指针（且如果表还有非聚集索引，还需要更新这些索引指向新的数据页）。而类似于自增列为聚集索引的，数据库系统可能并不拆分数据页，而只是简单的新添数据页。

> 2、从表中删除数据行

​    对删除数据行来说：删除行将导致其下方的数据行向上移动以填充删除记录造成的空白。如果删除的行是该数据页中的最后一行，那么该数据页将被回收，相应的索引页中的记录将被删除。对于数据的删除操作，可能导致索引页中仅有一条记录，这时，该记录可能会被移至邻近的索引页中，原索引页将被回收，即所谓的“索引 合并”。





**插入数据**

首先进行“Heap”：

修改表和索引的块，以及与之关联的undo块，同时用redo（重做日志缓冲区）来保护它们。

commit时，需要将redo写入磁盘中。

当出现宕机时，现将redo写入磁盘中。恢复时，通过redo重新进行操作。





**数据库隔离导致问题**

1. 脏读

   事务A读取了未提交的事务B的修改数据；

2. 不可重复读

   事务A读取同一条记录出现不同结果；

3. 幻读

   事务A查询 ”1“ 并修改 ”2“ ，事务B插入 “1” 后，事务A查询发现还有 “1”； 

   

**隔离级别**

（1）read uncommitted 未提交读

所有事务都可以看到没有提交事务的数据。

（2）read committed 提交读

事务成功提交后才可以被查询到。

（3）repeatable 重复读

同一个事务多个实例读取数据时，可能将未提交的记录查询出来，而出现幻读。mysql默认级别

（4）Serializable可串行化

***ps*** ： oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。

原文链接：https://blog.csdn.net/nanxiaotao/java/article/details/80412196





***触发器***

https://www.cnblogs.com/Jonecmnn/p/6416137.html

