| 属性          | 描述                                                | 备注                                                         |
| ------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| id            | 一个 namespace 下的 statement 的唯一标识            | 不同的 namespace 下可以定义相同的 id                         |
| parameterType | 执行 statement 传入的参数的类型                     | 该属性可以不填，MyBatis 会根据 TypeHandler 自动推断传入的参数类型 |
| resultType    | 从执行的 SQL 查询结果集的封装实体类型全限定名或别名 | 如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型；resultType 和 resultMap 之间只能同时使用一个 |
| resultMap     | mapper.xml 中定义的任意 resultMap 的 id 引用        | 如果引用的 resultMap 是在其他 mapper.xml 中，则引用的 id 为 [命名空间 + '.' + id] ；resultType 和 resultMap 之间只能同时使用一个 |
| useCache      | 查询结果是否保存至二级缓存                          | 默认 true                                                    |
| flushCache    | 执行 SQL 后会清空一级缓存（本地缓存）和二级缓存     | 默认 false ；所有 namespace 的一级缓存和当前 namespace 的二级缓存均会清除【1.2】 |
| timeout       | SQL 请求的最大等待时间（单位: 秒）                  | 默认无限制，推荐定义全局最大等待时间（ settings → defaultStatementTimeout ） |
| fetchSize     | 底层数据库驱动一次查询返回的结果行数                | 无默认值（依赖不同的数据库驱动），该配置与 MyBatis 无关，仅与底层数据库驱动有关【1.3】 |
| statementType | 底层使用的 Statement 的类型                         | 可选值：STATEMENT , PREPARED , CALLABLE ，默认 PREPARED ，底层使用 `PreparedStatement` |
| resultSetType | 控制 jdbc 中 ResultSet 对象的行为                   | 可选值：FORWARD_ONLY , SCROLL_SENSITIVE , SCROLL_INSENSITIVE , DEFAULT【1.4】 |
| databaseId    | 用于部分不同数据库厂商下使用的 SQL                  | 会加载所有不带 databaseId 的，以及匹配激活的数据源对应的数据库厂商的 databaseId 的 statement |



### select标签的flushCache

**`flushCache` 会清除全局一级缓存，以及本 namespace 下的二级缓存**。



### select标签下的fetchSize

`fetchSize` 作用：

*   **数据库驱动查询到数据后，每次只从数据库拉取 `fetchSize` 指定量的数据；**

*   **当这批数据都 next 完成后，再继续拉取下一批数据，以此来避免 OOM 现象的发生**。



>Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when more rows are needed for ResultSet objects generated by this Statement. If the value specified is zero, then the hint is ignored. The default value is zero.
>
>当此 `Statement` 生成的 `ResultSet` 对象需要更多行时，向 JDBC 驱动程序提供有关应从数据库中获取的行数的提示。如果指定的值为零，则忽略提示。默认值为零。



`fetchSize`的使用前提：

-   数据库环境支持（ Oracle 可以，高版本的 PostgreSQL (7.4+) 也可以，但 MySQL 不行）
-   执行 DQL 时，`Connection` 的 `autoCommit` 必须为 false （即开启事务）
-   查询结果的 `ResultSet` ，类型必须为 `TYPE_FORWARD_ONLY` （无法向相反的迭代方向滚动）（下面马上会提到）
-   只有一次发送一条 DQL 时才有用，如果用分号隔开一次性发送多条 DQL ，也不好使（ 如 `select * from tbl_department; select * from tbl_user;`）





### ResultMap - 结果集映射



#### resultMap+prefix引用其他resultMap

通过association标签关联到 **已经声明的resultMap** ，并且**通过 columnPrefix属性 -`class_` 匹配语句中查询出来的字段信息**

mapper文件中的resultMap和sql语句内容：

```xml
<resultMap id="UserClass" type="com.example.entity.UserClass">
    <id column="id" property="classId"/>
    <result column="name" property="className"/>
</resultMap>

<resultMap id="UserInfoWithClass" type="com.example.entity.UserWithClass">
    <constructor>
        <idArg column="id" javaType="_int"/>
    </constructor>
    <result column="name" property="name"/>
    <result column="phone" property="phone"/>
    <association property="userClass" javaType="com.example.entity.UserClass"
                 columnPrefix="class_" resultMap="UserClass"/>
</resultMap>

<select id="selectUserWithClassById" resultMap="UserInfoWithClass">
    select a.id as id, name, phone, class_id, class_name
    from users a
    inner join class c on class_id = c.id
    where a.id = #{id}
</select>
```

输出的日志内容为：

 ```shell
 ==>  Preparing: select a.id as id, name, phone, class_id, class_name from users a inner join class c on class_id = c.id where a.id = ?
 ==> Parameters: 1(Integer)
 <==    Columns: id, name, phone, class_id, class_name
 <==        Row: 1, ni hao, 559710330a1b9ff5bdabe7c65c2767cb, 1, 一年级一班
 <==      Total: 1
 UserWithClass(id=1, name=UserName(name=你好), phone=ClientPhone(phone=18369185667), userClass=UserClass(classId=1, className=一年级一班))
 ```





#### 直接引用resultMap

直接引用resultMap时，需要注意 ***查询出的 column字段名称要与引用的 resultMap一致***

例如下面的反例：

当直接引用的是**UserClassPre**时，按照resultMap中的column属性值直接映射

```xml
<resultMap id="UserClass" type="com.example.entity.UserClass">
    <id column="class_id" property="classId"/>
    <result column="class_name" property="className"/>
</resultMap>

<resultMap id="UserClassPre" type="com.example.entity.UserClass">
    <id column="id" property="classId"/>
    <result column="name" property="className"/>
</resultMap>

<resultMap id="UserInfoWithClassByLombok" type="com.example.entity.user.UserWithClassByLombok">
    <id column="id" property="id"/>
    <result column="name" property="name"/>
    <result column="phone" property="phone"/>
    <association property="userClass" javaType="com.example.entity.UserClass"
                 resultMap="UserClassPre"/>
</resultMap>

<select id="selectLombokUserWithClassById" resultMap="UserInfoWithClassByLombok">
    select a.id as id, name, phone, class_id, class_name
    from users a
    inner join class c on class_id = c.id
    where a.id = #{id}
</select>
```

就出现了下面的错误映射情况**：将用户的姓名，映射到了班级的Bo中**

```####shell
Logging initialized using 'class org.apache.ibatis.logging.stdout.StdOutImpl' adapter.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
Opening JDBC Connection
Created connection 1111100957.
Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@423a0e1d]
==>  Preparing: select a.id as id, name, phone, class_id, class_name from users a inner join class c on class_id = c.id where a.id = ?
==> Parameters: 1(Integer)
<==    Columns: id, name, phone, class_id, class_name
<==        Row: 1, ni hao, 559710330a1b9ff5bdabe7c65c2767cb, 1, 一年级一班
<==      Total: 1
UserWithClassByLombok(id=1, name=UserName(name=你好), phone=ClientPhone(phone=18369185667), userClass=UserClass(classId=1, className=ni hao))
Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@423a0e1d]
Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@423a0e1d]
Returned connection 1111100957 to pool.

Process finished with exit code 0
```





#### resultMap的继承

通过extend属性，表明该resultMap继承的父类Map属性

下面的demo中

**UserInfoWithClassByExtend** 的map继承了 **User**，则自动就包含了`id`，`name`，`phone`三个字段的信息；节省了很多重复的代码。

```xml
<resultMap id="UserClass" type="com.example.entity.UserClass">
    <id column="class_id" property="classId"/>
    <result column="class_name" property="className"/>
</resultMap>

<resultMap id="User" type="com.example.entity.User">
    <id column="id" property="id"/>
    <result column="name" property="name"/>
    <result column="phone" property="phone"/>
</resultMap>

<resultMap id="UserInfoWithClassByExtend" type="com.example.entity.user.UserWithClassByLombok"
           extends="User">
    <association property="userClass" javaType="com.example.entity.UserClass"
                 resultMap="UserClass"/>
</resultMap>

<select id="selectExtendUserWithClassById" resultMap="UserInfoWithClassByLombok">
    select a.id as id, name, phone, class_id, class_name
    from users a
    inner join class c on class_id = c.id
    where a.id = #{id}
</select>
```

输出结果如下：

```shell
Logging initialized using 'class org.apache.ibatis.logging.stdout.StdOutImpl' adapter.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
Opening JDBC Connection
Created connection 1111100957.
Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@423a0e1d]
==>  Preparing: select a.id as id, name, phone, class_id, class_name from users a inner join class c on class_id = c.id where a.id = ?
==> Parameters: 1(Integer)
<==    Columns: id, name, phone, class_id, class_name
<==        Row: 1, ni hao, 559710330a1b9ff5bdabe7c65c2767cb, 1, 一年级一班
<==      Total: 1
UserWithClassByLombok(id=1, name=UserName(name=你好), phone=ClientPhone(phone=18369185667), userClass=UserClass(classId=1, className=一年级一班))
Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@423a0e1d]
Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@423a0e1d]
Returned connection 1111100957 to pool.

Process finished with exit code 0
```





### 鉴别器

**根据某些条件，决定如何做 / 如何选**。下面我们通过一个简单的需求来讲解 discriminator 的使用

摘自小册的一个例子

```xml
<resultMap id="userWithDiscriminator" type="com.linkedbear.mybatis.entity.User">
    <discriminator column="deleted" javaType="boolean">
        <case value="false" resultMap="userlazy"/>
        <case value="true" resultType="com.linkedbear.mybatis.entity.User"/>
    </discriminator>
</resultMap>
```



-------------

注意：

*   `<constructor>`标签不支持自动装箱，需要通过 “_int”方式，找到基础类型的构造器上
*   mapper文件在不指定构造器的情况下，默认使用无参构造器



总结：

**所有的与Mybatis交互的JavaType，使用默认的无参构造器；**

*    **默认不适用constructor标签**
*    **当使用lombok注解的情况，请增加@NoArgsConstructor注解**
*    **主动声明了参数构造器后，请主动增加无参构造器，防止出现问题**

